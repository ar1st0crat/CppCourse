# Лекция 4 - Наследование

План:

* Наследование как принцип ООП и механизм повторного использования кода, отношение **is-a**
* Спецификатор доступа protected, явный доступ к данным базового класса
* Конструкторы и деструкторы подклассов, порядок создания и удаления классов и подклассов
* Доопределение базовых классов, классы и подклассы в памяти
* Переопределение членов-данных и методов базовых классов
* Сокрытие, инструкция using
* Антипаттерн "Отказ от наследства"
* Виды наследования по доступу: закрытое, защищенное, открытое *(С++ only)*
* Множественное наследование, виртуальное наследование *(C++ only)*
* Заметки кулхацкера: хоть прайвэт, хоть протэктэд - доступ прямо из мейна


### Классы Car и Truck - наследники класса Vehicle

До этого у нас был класс Car, которым мы кодировали сущность легкового автомобиля. Но наш такси-сервис катает не только людей, а и их чемоданы ("Гена, а давай я возьму чемодан, а ты возьмешь меня?" (с) Чебурашка). Поэтому нормальным решением будет выделить класс автомобиля Vehicle и отнаследовать от него легковой автомобиль (Car) и грузовой (Truck). Концептуально они будут пока отличаться лишь тем, что у грузового есть свойство максимально возможной загрузки (```max_weight_```), у легкового выделено отдельное свойство - количество мест (```seat_count_```).

С технической точки зрения на примере класса Truck демонстрируется доопределение и переопределение метода ```void print() const``` базового класса Vehicle, а также затаившеся-бажное переопределение базового свойства ```color_``` в подклассе.


### Классы Operator и Driver - наследники класса Employee

На примере класса Operator демонстрируется решение вопроса с сокрытием метода ```void print() const``` базового класса Employee. Подробнее - см. в коде.


### Хэдер misc.h

Здесь собран код для демонстрации вопросов, указанных в последних 3 пунктах плана лекции.

В конце функции ```int main()``` обходим всякие там private и protected:

```C++
    // =============== Эй хакнем! ===============

    EasyToHack lolkek;
    lolkek.print();

    // lolkek.foo_ = 300;         // не получится
    // lolkek.bar_ = 6.28;     // не получится

    // а так:
    int* iptr = (int*)&lolkek;

    *iptr = 300;        // !

    iptr++;             // смещаемся дальше на размер инта
    iptr++;             // вопрос на засыпку: а еще раз зачем??

    double* dptr = (double*)iptr;
    *dptr = 6.28;

    lolkek.print();
```


Классы на данный момент: 

![uml](https://github.com/ar1st0crat/CppCourse/blob/master/Lectures/Lec04%20-%20Inheritance/uml.png)
